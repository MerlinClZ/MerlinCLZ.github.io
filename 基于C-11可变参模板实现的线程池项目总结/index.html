<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="基于C++11可变参模板实现的线程池项目总结, Cheng Wenqing&#39;s Blog">
    <meta name="description" content="线程池项目环境：vs2019开发、C++17标准；centos7编译so动态库
一.项目介绍作为五大池之一 (内存池、连接池、线程池、进程池、协程池)，线程池的应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>基于C++11可变参模板实现的线程池项目总结 | Cheng Wenqing&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Cheng Wenqing&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Cheng Wenqing&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">基于C++11可变参模板实现的线程池项目总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/">
                                <span class="chip bg-color">个人项目</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-02-20
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="线程池项目"><a href="#线程池项目" class="headerlink" title="线程池项目"></a>线程池项目</h1><p><strong>环境：</strong>vs2019开发、C++17标准；centos7编译so动态库</p>
<h2 id="一-项目介绍"><a href="#一-项目介绍" class="headerlink" title="一.项目介绍"></a>一.项目介绍</h2><p>作为五大池之一 (内存池、连接池、线程池、进程池、协程池)，线程池的应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。有很多开源的线程池实现，虽然各自接口使用上稍有区别，但是其核心实现原理都是基本相同的。</p>
<h2 id="二-技术背景"><a href="#二-技术背景" class="headerlink" title="二.技术背景"></a>二.技术背景</h2><ul>
<li><p>熟练基于C++ 11标准的面向对象编程</p>
<p>组合和继承、继承多态、STL容器、智能指针、函数对象、绑定器、可变参模板编程等。</p>
</li>
<li><p>熟悉C++11多线程编程</p>
</li>
</ul>
<p>​        thread、mutex、atomic、condition_variable、unique_lock等。</p>
<ul>
<li>C++17和C++20标准的内容</li>
</ul>
<p>​       C++17的any类型和C++20的信号量semaphore, 项目上的代码实现。</p>
<ul>
<li>熟悉多线程理论</li>
</ul>
<p>​       多线程基本知识、线程互斥、线程同步、原子操作、CAS等。</p>
<h2 id="三-并发和并行"><a href="#三-并发和并行" class="headerlink" title="三.并发和并行"></a>三.并发和并行</h2><ul>
<li>CPU单核</li>
<li>CPU多核、多CPU</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>单核上，多个线程占用不同的CPU时间片，物理上还是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），看起来就像是多个线程都在共同执行一样，这样的场景称作并发<br>（concurrent）。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>在多核或者多CPU上，多个线程是在真正的同时执行，这样的场景称作并行（parallel）。</p>
<h2 id="四-多线程的优势"><a href="#四-多线程的优势" class="headerlink" title="四.多线程的优势"></a>四.多线程的优势</h2><p>多线程程序一定就好吗？不一定，要看具体的应用场景：</p>
<p>程序是IO密集型？  程序里面指令的执行，涉及一些IO操作，比如设备、文件、网络操作（等待客户端的连接 IO操作是可以把程序阻塞住的，再分配给这样程序CPU时间片，CPU相当于空闲下来了）</p>
<p>程序是CPU密集型？  程序里面的指令都是做计算用的</p>
<h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><p>无论是CPU单核、CPU多核、多CPU，都是比较适合多线程程序的</p>
<h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><ul>
<li><p>CPU单核 （不适合设计成多线程程序）</p>
<p>多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线程一直进行计算。</p>
</li>
<li><p>CPU多核、多CPU</p>
<p>多个线程可以并行执行，对CPU利用率好。</p>
</li>
</ul>
<h2 id="五-线程池"><a href="#五-线程池" class="headerlink" title="五.线程池"></a>五.线程池</h2><h3 id="线程的消耗"><a href="#线程的消耗" class="headerlink" title="线程的消耗"></a>线程的消耗</h3><p>为了完成任务，创建很多的线程可以吗？线程真的是越多越好？</p>
<ul>
<li>线程的创建和销毁都是非常”重”的操作</li>
<li>线程栈本身占用大量内存</li>
<li>线程的上下文切换要占用大量时间</li>
<li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机</li>
</ul>
<h3 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h3><p>​       操作系统上创建线程和销毁线程都是很”重”的操作，耗时耗性能都比较多，那么在服务执行的过程中， 如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能 降低，业务的处理能力也会降低。 </p>
<p>​       线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线 程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，task执行 完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务。</p>
<h4 id="fixed模式线程池"><a href="#fixed模式线程池" class="headerlink" title="fixed模式线程池"></a>fixed模式线程池</h4><p>线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。</p>
<h4 id="cached模式线程池"><a href="#cached模式线程池" class="headerlink" title="cached模式线程池"></a>cached模式线程池</h4><p>线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程 数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了60s还没 有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="1-线程互斥"><a href="#1-线程互斥" class="headerlink" title="1.线程互斥"></a>1.线程互斥</h4><p>能不能在多线程环境下执行？？？ 看这段代码是否存在竟态条件 -&gt;称作临界区代码段 &#x3D;&#x3D;&#x3D;》保证它的原子操作。</p>
<p>如果在多线程环境是不存在竟态条件的&#x3D;&#x3D;》 可重入的</p>
<p>​                                       存在竟态条件  &#x3D;&#x3D;》不可重入的！</p>
<p>竟态条件：代码片段在多线程环境下执行，随着线程的调度顺序不同，而得到不同的运行结果！</p>
<ul>
<li><p>1.1互斥锁mutex</p>
</li>
<li><p>1.2atomic原子类型  CAS操作（无锁机制）无锁队列、无锁链表、无锁数组</p>
</li>
</ul>
<h5 id="1-1互斥锁mutex"><a href="#1-1互斥锁mutex" class="headerlink" title="1.1互斥锁mutex"></a>1.1互斥锁mutex</h5><p>在C++中，<code>std::mutex</code>是用于多线程同步的一个关键工具，它代表了一种互斥量（Mutex），用来保护共享资源免受多个线程同时访问的影响。当你有多条线程可能同时访问同一段临界区代码或同一个全局变量时，可以使用<code>std::mutex</code>来确保在同一时刻只有一个线程能够进入临界区并对资源进行操作。</p>
<p>以下是<code>std::mutex</code>的一些基本用法：</p>
<h6 id="1-1-1-定义和初始化mute"><a href="#1-1-1-定义和初始化mute" class="headerlink" title="1.1.1 定义和初始化mute:"></a>1.1.1 定义和初始化mute:</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认构造一个互斥锁，初始状态为未锁定</span>
<span class="token comment" spellcheck="true">// 或者显式初始化</span>
std<span class="token operator">::</span>mutex <span class="token function">mtx2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>defer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化为延迟锁定状态</span>
</code></pre>
<h6 id="1-1-2-加锁和解锁"><a href="#1-1-2-加锁和解锁" class="headerlink" title="1.1.2 加锁和解锁"></a>1.1.2 加锁和解锁</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用RAII方式自动锁定和解锁</span>
    <span class="token comment" spellcheck="true">// 进入临界区，此处的代码仅在一个线程中执行</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当离开这个作用域时，lock_guard会自动释放锁</span>

<span class="token comment" spellcheck="true">// 或者手动管理锁</span>
<span class="token keyword">void</span> <span class="token function">anotherFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 手动锁定</span>
    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 进入临界区</span>
        <span class="token comment" spellcheck="true">// ...</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 异常处理，记得解锁</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> finally <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 手动解锁</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h6 id="1-1-3-使用std-unique-lock进行更灵活的锁定"><a href="#1-1-3-使用std-unique-lock进行更灵活的锁定" class="headerlink" title="1.1.3 使用std::unique_lock进行更灵活的锁定"></a>1.1.3 使用<code>std::unique_lock</code>进行更灵活的锁定</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">flexibleLocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">someCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 解锁以便其他线程可以进入</span>
        <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再次锁定</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 继续在临界区工作</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h6 id="1-1-4-阻塞和超时锁定"><a href="#1-1-4-阻塞和超时锁定" class="headerlink" title="1.1.4 阻塞和超时锁定"></a>1.1.4 阻塞和超时锁定</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">timedLockAttempt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置超时时间为1秒</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">,</span> std<span class="token operator">::</span>try_to_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尝试非阻塞获取锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">owns_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有获取到锁</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mtx<span class="token punctuation">.</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 阻塞尝试获取锁，最多等待指定时间</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取锁失败，超时</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 已经获得锁，执行临界区代码</span>
    <span class="token comment" spellcheck="true">// ...</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h6 id="1-1-5-注意事项"><a href="#1-1-5-注意事项" class="headerlink" title="1.1.5. 注意事项"></a>1.1.5. 注意事项</h6><ul>
<li><code>std::mutex</code>不支持线程间的递归锁定，试图在已经持有锁的线程中再次锁定同一个互斥量会导致死锁。如果需要递归锁定，应使用<code>std::recursive_mutex</code>。</li>
<li>在多线程程序中，必须小心处理锁定和解锁操作，确保每次锁定都有对应的解锁，否则可能出现死锁或资源泄露。</li>
<li>使用<code>std::lock_guard</code>或<code>std::unique_lock</code>这样的RAII（Resource Acquisition Is Initialization）机制可以简化代码并确保在抛出异常时也能正确解锁。</li>
</ul>
<h6 id="1-1-6-示例代码片段"><a href="#1-1-6-示例代码片段" class="headerlink" title="1.1.6. 示例代码片段"></a>1.1.6. 示例代码片段</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">incrementCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">guard</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" incremented count to "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> threads<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> NUM_THREADS <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        threads<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>incrementCounter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 等待所有线程完成</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final count value: "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>上述代码创建了10个线程，每个线程都会锁定<code>mtx</code>然后递增全局变量<code>count</code>。由于<code>std::lock_guard</code>的存在，可以确保在任何时候只有一个线程在修改<code>count</code>，从而避免了竞态条件。</p>
<p><strong>lock_guard和unique_lock的用法</strong></p>
<p><code>std::unique_lock</code> 和 <code>std::lock_guard</code> 都是用来管理互斥量（mutex）的对象，它们都是C++标准库中的类模板，用于自动管理互斥锁的生命周期，以防止在程序中忘记解锁互斥量造成死锁。下面分别举例说明它们的作用和使用。</p>
<blockquote>
<p><strong>std::lock_guard</strong></p>
<p><code>std::lock_guard</code> 是一种非常简单的 RAII（Resource Acquisition Is Initialization）工具，它在构造时自动锁定互斥量，在析构时自动解锁互斥量。这种特性确保了只要 lock_guard 对象存在，互斥量就会保持锁定状态，而且在任何情况下（包括异常抛出）都能正确解锁互斥量。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">printWithLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 构造时自动锁定互斥量</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Critical section accessed by thread "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 临界区代码</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lock_guard析构时自动解锁互斥量</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>printWithLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>printWithLock<span class="token punctuation">)</span><span class="token punctuation">;</span>

t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><code>printWithLock</code> 函数内的代码段是临界区，两个线程通过创建 <code>std::lock_guard</code> 对象来保证同一时间内只有一个线程能进入并执行这段代码。</p>
<p><strong>std::unique_lock</strong></p>
<p><code>std::unique_lock</code> 提供了更多的灵活性，它可以<strong>手动锁定和解锁互斥量，可以选择是否在构造时立即锁定，也可以在后续的代码中决定何时锁定和解锁。</strong>此外，它还提供了 <code>try_lock</code> 和 <code>try_lock_for</code> 等方法，可以尝试锁定而不阻塞线程，以及尝试在一定时间内锁定互斥量。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span>

std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>shouldContinue<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">,</span> std<span class="token operator">::</span>defer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不立即锁定，而是延迟锁定</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>shouldContinue<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 尝试非阻塞地锁定互斥量</span>
  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" has the lock.\n"</span><span class="token punctuation">;</span>
      std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模拟工作</span>
      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 手动解锁互斥量</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果没能获取到锁，则让出CPU</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> shouldContinue <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>shouldContinue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>shouldContinue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 主线程等待一段时间</span>
shouldContinue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 改变条件，使工作线程退出循环</span>

t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p><code>worker</code> 函数使用 <code>std::unique_lock</code> 并设置为延迟锁定。在循环中尝试获取锁，如果获取成功则执行任务并手动解锁，否则让出处理器时间片。当外部条件变化时，线程停止尝试获取锁并退出循环。</p>
</blockquote>
<h4 id="2-线程通信"><a href="#2-线程通信" class="headerlink" title="2.线程通信"></a>2.线程通信</h4><ul>
<li><p>条件变量 condition_variable</p>
</li>
<li><p>信号量 semaphore（C++20）</p>
<p>可以使用C++11条件变量实现信号量</p>
</li>
</ul>
<h5 id="2-1-条件变量"><a href="#2-1-条件变量" class="headerlink" title="2.1 条件变量"></a>2.1 条件变量</h5><p>​	C++中的条件变量是一种线程同步机制，它主要用于<strong>解决线程间通信</strong>的问题，特别是在一个多线程环境里，<strong>当一个线程需要等待某个特定条件满足后再继续执行时</strong>，条件变量就派上了用场。条件变量不能单独使用，它总是配合互斥量（通常是<code>std::mutex</code>）一起使用，以确保线程安全性和同步的有效性。</p>
<blockquote>
<p>条件变量的核心概念和功能如下：</p>
<ol>
<li><strong>等待条件</strong>：</li>
</ol>
<ul>
<li>线程通过调用条件变量的<code>wait()</code>方法来挂起自己，直到满足特定的条件。在调用<code>wait()</code>之前，线程必须已获得互斥锁，这样就能保证在检查和等待条件的过程中，不会发生数据竞争。</li>
<li><code>wait()</code>会自动释放互斥锁，让其他线程有机会修改共享数据，进而可能满足等待的条件。</li>
</ul>
<ol start="2">
<li><strong>触发条件</strong>：</li>
</ol>
<ul>
<li>另一个线程在满足条件后，可以调用条件变量的<code>notify_one()</code>或<code>notify_all()</code>方法来唤醒一个或所有正在等待该条件变量的线程。</li>
<li>唤醒并不立即传递控制权给等待的线程，而是让等待的线程回到<code>wait()</code>函数内部，这时它会重新获取互斥锁并检查条件是否仍然满足。如果满足，则继续执行；如果不满足，可能会再次进入等待状态。</li>
</ul>
<ol start="3">
<li><strong>限时等待</strong>：</li>
</ol>
<ul>
<li>C++11标准还提供了<code>wait_for()</code>和<code>wait_until()</code>方法，允许线程在等待条件满足的同时设定一个超时时间，超过这个时间后，即使条件没有满足也会返回，避免无限期地等待。</li>
</ul>
<ol start="4">
<li><strong>使用模式</strong>：</li>
</ol>
<ul>
<li>使用条件变量的典型模式包括：<ul>
<li>线程首先锁定互斥锁。</li>
<li>检查条件是否满足，如果不满足，则调用<code>wait()</code>函数释放互斥锁并等待。</li>
<li>当其他线程改变了条件并调用了通知函数后，等待的线程被唤醒，重新获取互斥锁并检查条件，如果条件满足则继续执行，否则可能再次进入等待。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>成员函数</strong>：</li>
</ol>
<ul>
<li><pre><code>std::condition_variable
</code></pre>
<p>类的主要成员函数包括：</p>
<ul>
<li><code>wait()</code>：挂起当前线程并释放互斥锁。</li>
<li><code>wait(lock)</code>：接受一个<code>std::unique_lock&lt;std::mutex&gt;</code>作为参数，同样挂起线程并释放锁。</li>
<li><code>wait(lock, predicate)</code>：除了等待外，还会在唤醒后检查一个谓词（一个返回布尔值的函数对象），只有当谓词返回<code>true</code>时，线程才会继续执行。</li>
<li><code>notify_one()</code>：唤醒一个正在等待的线程。</li>
<li><code>notify_all()</code>：唤醒所有正在等待的线程。</li>
<li>通过以上机制，条件变量使得线程能够在复杂同步场景中更加高效地协作，避免了无效的轮询和不必要的阻塞。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="2-2-信号量"><a href="#2-2-信号量" class="headerlink" title="2.2 信号量"></a>2.2 信号量</h5><p>​	在C++中，信号量是一种线程同步机制，它<strong>用来控制有限资源的访问或限制同时执行特定任务的线程数量</strong>。信号量维护一个整数值，该值可以增加（信号&#x2F;发布）或减少（等待&#x2F;获取），并且可以用来阻塞线程直到特定条件达成。</p>
<p>C++标准库直到C++20才正式包含了信号量的原生支持，通过<code>std::semaphore</code>类实现。在此之前，开发者需要依赖第三方库或操作系统API来实现信号量功能。C++20中引入的<code>std::semaphore</code>有两种形式：计数信号量（<code>std::counting_semaphore</code>）和二进制信号量（<code>std::binary_semaphore</code>）。</p>
<blockquote>
<p><strong>计数信号量（std::counting_semaphore）</strong></p>
<ul>
<li>计数信号量有一个非负整数计数器，它表示可用资源的数量。</li>
<li>初始化时指定一个初始计数值。</li>
<li><code>acquire()</code>（相当于P操作）：当信号量的计数值大于0时，调用此函数会使计数值减1，并允许线程继续执行；若计数值为0，则线程会被阻塞，直到其他线程调用<code>release()</code>函数增加了计数值。</li>
<li><code>release()</code>（相当于V操作）：增加信号量的计数值，如果至少有一个线程正阻塞在这个信号量上，那么将唤醒一个等待的线程。</li>
</ul>
<p><strong>二进制信号量（std::binary_semaphore）</strong></p>
<ul>
<li>二进制信号量类似于互斥量，但它没有所有权的概念，只有两种状态：有信号（计数值为1）和无信号（计数值为0）。</li>
<li>同样具有<code>acquire()</code>和<code>release()</code>操作，但计数值只能是0或1。</li>
</ul>
<p><strong>示例用法（C++20之后）：</strong></p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;semaphore></span></span>

std<span class="token operator">::</span>counting_semaphore<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">></span> semaphore<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化一个最多允许5个线程同时访问的信号量</span>

<span class="token keyword">void</span> <span class="token function">threadFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求资源，如果资源不足则阻塞</span>
  <span class="token comment" spellcheck="true">// ... 进行临界区操作，访问共享资源 ...</span>
  semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 释放资源，允许其他线程进入</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>jthread<span class="token operator">></span> threads<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      threads<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>threadFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
在C<span class="token operator">++</span><span class="token number">11</span>及以前版本中，由于标准库并未提供信号量，开发者通常借助于条件变量、互斥量或者其他第三方库模拟信号量的行为。而在C<span class="token operator">++</span><span class="token number">20</span>以后，可以直接使用内置的信号量类实现更为简洁和直观的同步控制。
</code></pre>
</blockquote>
<h2 id="六-项目设计"><a href="#六-项目设计" class="headerlink" title="六.项目设计"></a>六.项目设计</h2><p><img src="https://gcdnb.pbrd.co/images/Ax86hJ8NRx5e.png?o=1"></p>
<h3 id="1-threadp-ool-h接口"><a href="#1-threadp-ool-h接口" class="headerlink" title="1.threadp!()ool.h接口"></a>1.threadp!()ool.h接口</h3><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一.线程池类型</span>
<span class="token keyword">class</span> <span class="token class-name">ThreadPool</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//二.线程类型</span>
<span class="token keyword">class</span> <span class="token class-name">Thread</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">private</span><span class="token operator">:</span>  
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//三.线程池支持的模式</span>
<span class="token comment" spellcheck="true">//支持两种线程模式</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">PoolMode</span>   
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
MODE_FIXED<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//固定数量的线程</span>
MODE_CACHED<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程数量可动态增长</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//四.任务抽象基类</span>
<span class="token comment" spellcheck="true">// 用户可以自定义任意任务类型，从task继承，重写run方法，实现自定义任务处理</span>
<span class="token keyword">class</span> <span class="token class-name">Task</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h3 id="2-ThreadPool类设计"><a href="#2-ThreadPool类设计" class="headerlink" title="2.ThreadPool类设计"></a>2.ThreadPool类设计</h3><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadPool</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">//线程池构造</span>
<span class="token function">ThreadPool</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//线程池析构</span>
<span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//2.  设置线城池的工作模式</span>
<span class="token keyword">void</span> <span class="token function">setMode</span><span class="token punctuation">(</span>PoolMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//3.   设置task任务队列上限的阈值</span>
<span class="token keyword">void</span> <span class="token function">setTaskQueMaxThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//设置线程池catched模式下线程阈值</span>
<span class="token keyword">void</span> <span class="token function">setThreadSizeThreshHold</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//4.   给线程池提交任务</span>
Result <span class="token function">submitTask</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户可能会传入生命周期比较短的任务,使用智能指针封装任务</span>

<span class="token comment" spellcheck="true">//1.  开启线程池</span>
<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> initThreadSize <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadPool<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//禁止对象拷贝构造功能</span>
ThreadPool<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadPool<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//禁止对象赋值操作符</span>


<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">//定义线程函数</span>
<span class="token keyword">void</span> <span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadid<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//检查pool的运行状态</span>
<span class="token keyword">bool</span> <span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment" spellcheck="true">//linux下 -std=c++11</span>
<span class="token comment" spellcheck="true">//1.std::vector&lt;std::unique_ptr&lt;Thread>>threads_;//线程列表</span>
std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Thread<span class="token operator">>></span>threads_<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//线程列表</span>

size_t initThreadSize_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.初始的线程数量    size_t无符号整型</span>
std<span class="token operator">::</span>atomic_int curThreadSize_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.记录当前线程池里面线程的总数量 不是线程安全的,使用互斥锁太重,故使用原子类型</span>
<span class="token keyword">int</span> threadSizeThreshHold_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程数量上限阈值</span>
std<span class="token operator">::</span>atomic_int idleThreadSize_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录空闲线程的数量</span>

std<span class="token operator">::</span>queue<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">>></span>taskQue_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3.任务队列</span>
std<span class="token operator">::</span>atomic_int taskSize_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//5.任务数量， 原子操作保证内部任务调度与外部任务增加</span>
<span class="token keyword">int</span> taskQueMaxThreshold_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//6.任务队列数量上限阈值</span>

std<span class="token operator">::</span>mutex taskQueMtx_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//7.保证任务队列的线程安全</span>
std<span class="token operator">::</span>condition_variable notFull_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//8.表示任务队列不满</span>
std<span class="token operator">::</span>condition_variable notEmpty_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//9.表示任务队列不空</span>
std<span class="token operator">::</span>condition_variable exitCond_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待线程资源全部回收</span>

PoolMode poolMode_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前线程池的工作模式</span>
std<span class="token operator">::</span>atomic_bool isPoolrunning_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表示当前线程池的启动状态  多个线程中使用可能会发生线程安全问题</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h3 id="3-ThreadPool方法接口实现-线程池方法实现"><a href="#3-ThreadPool方法接口实现-线程池方法实现" class="headerlink" title="3.ThreadPool方法接口实现(线程池方法实现)"></a>3.ThreadPool方法接口实现(线程池方法实现)</h3><h4 id="3-1线程池方法实现"><a href="#3-1线程池方法实现" class="headerlink" title="3.1线程池方法实现"></a>3.1线程池方法实现</h4><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"threadpool.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;functional></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> TASK_MAX_THRESHOLD <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> THREAD_MAX_THRESHOLD <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> THREAD_MAX_IDLE_TIME <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单位s</span>

<span class="token comment" spellcheck="true">//一、线程池方法实现</span>
<span class="token comment" spellcheck="true">//1. 线程池构造</span>
ThreadPool<span class="token operator">::</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">:</span> <span class="token function">initThreadSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  
<span class="token punctuation">,</span> <span class="token function">taskSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">idleThreadSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">curThreadSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token function">taskQueMaxThreshold_</span><span class="token punctuation">(</span>TASK_MAX_THRESHOLD<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//（项目中除了0 1不能出现其他数字，其他数字用有意义的名字表示 ）</span>
<span class="token punctuation">,</span><span class="token function">threadSizeThreshHold_</span><span class="token punctuation">(</span>THREAD_MAX_THRESHOLD<span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">poolMode_</span><span class="token punctuation">(</span>PoolMode<span class="token operator">::</span>MODE_FIXED<span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">isPoolrunning_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//2. 线程池析构     C++中只要出现了构造一定要有析构</span>
ThreadPool<span class="token operator">::</span><span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
isPoolrunning_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//等待线程池里面所有的线程返回  有两种状态： 阻塞 &amp; 正在执行任务中</span>
std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
exitCond_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> threads_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//3. 设置线城池的工作模式</span>
<span class="token keyword">void</span> ThreadPool<span class="token operator">::</span><span class="token function">setMode</span><span class="token punctuation">(</span>PoolMode mode<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
poolMode_ <span class="token operator">=</span> mode<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//4. 设置task任务队列上线的阈值</span>
<span class="token keyword">void</span> ThreadPool<span class="token operator">::</span><span class="token function">setTaskQueMaxThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshold<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
taskQueMaxThreshold_ <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//设置线程cached模式下线程阈值</span>
<span class="token keyword">void</span> ThreadPool<span class="token operator">::</span><span class="token function">setThreadSizeThreshHold</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshold<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>poolMode_ <span class="token operator">==</span> PoolMode<span class="token operator">::</span>MODE_CACHED<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  threadSizeThreshHold_ <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h4 id="3-2-ThreadPool-start-的实现"><a href="#3-2-ThreadPool-start-的实现" class="headerlink" title="3.2 ThreadPool::start()的实现"></a>3.2 ThreadPool::start()的实现</h4><p>线程池ThreadPool::start()开启线程池函数的实现</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//6. 开启线程池</span>
<span class="token keyword">void</span> ThreadPool<span class="token operator">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> initThreadSize<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//设置线程池的运行状态</span>
isPoolrunning_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//1.记录初始线程个数</span>
initThreadSize_ <span class="token operator">=</span> initThreadSize<span class="token punctuation">;</span>
curThreadSize_ <span class="token operator">=</span> initThreadSize<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//2.创建线程对象</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> initThreadSize_<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//创建thread线程对象的时候，把线程函数给到thread线程对象</span>
  std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Thread<span class="token operator">></span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ThreadPool<span class="token operator">::</span>threadFunc<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span>              std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//threads_.emplace_back(new Thread(std::bind(&amp;ThreadPool::threadFunc,this)));</span>
  <span class="token comment" spellcheck="true">//threads_.emplace_back(std::move(ptr));//原本（ptr）但是unique_ptr禁止了拷贝构造，实参ptr转为形参ptr底层会拷贝一份，</span>
                                          <span class="token comment" spellcheck="true">//所以使用move移动语义做资源转移</span>
  <span class="token comment" spellcheck="true">//threads_.emplace_back(ptr)报错原因,实参到形参,threads_尝试拷贝构造一份ptr并插入到线程池中,unique_ptr禁用了拷贝构造和赋值构造</span>

  <span class="token keyword">int</span> threadId <span class="token operator">=</span> ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  threads_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>threadId<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//启动所有线程 std::vector&lt;Thread*>threads_;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> initThreadSize_<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  threads_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//需要去执行一个线程函数  线程函数放在线程类里面无法访问线程池的私有变量，</span>
                         <span class="token comment" spellcheck="true">//1.可以将线程函数定义为全局函数，2.将线程函数定义在线程池类中。</span>
  idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//记录初始空闲线程的数量</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p>线程池工作需要调用线程池start函数, 线程工作需要调用线程start函数, 线程的start函数需要在线程池中定义, 因为线程池的参数都在线程池类的private作用域中.</p>
<p>线程调用线程池中的线程启动函数start(), 需要在线程创建时候将线程池中的start()函数动态绑定到线程中, 方法是使用function函数和绑定器.</p>
<h5 id="function函数作用"><a href="#function函数作用" class="headerlink" title="function函数作用?"></a><strong>function函数作用?</strong></h5><p>在C++中，<code>std::function</code> 是C++标准库中的一部分，它是一个泛型函数包装器类模板，主要作用如下：</p>
<ol>
<li><strong>类型擦除</strong>：<code>std::function</code> 可以容纳任何形式的可调用对象，如全局函数、成员函数、Lambda 表达式、仿函数（functor）等，并将其转换成统一的类型。这意味着你可以定义一个<code>std::function</code>变量，它能够存储不同类型的可调用对象，提供了类型安全的函数指针类似的功能。</li>
<li><strong>存储和延迟调用</strong>：<code>std::function</code> 对象可以存储任意可调用实体，允许你在稍后合适的时间点调用它，这对于实现回调函数、事件处理器等非常有用。</li>
<li><strong>多态性</strong>：由于其能够存储多种类型的可调用对象，所以它可以支持运行时多态，即在运行时确定调用哪个具体的函数。</li>
<li><strong>方便传参和容器化</strong>：<code>std::function</code> 对象可以作为函数参数传递，也可以放入容器（如 <code>std::vector&lt;std::function&lt;...&gt;&gt;</code>）中，使得程序设计更加灵活和模块化。</li>
</ol>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>

<span class="token comment" spellcheck="true">// 声明一个普通的函数</span>
<span class="token keyword">void</span> <span class="token function">simpleFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Called simpleFunction with "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 定义一个类，包含一个成员函数</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">void</span> <span class="token function">memberFunction</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Called memberFunction with "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 创建一个std::function对象，能接受一个int参数并返回无值</span>
std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> func<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 将自由函数赋值给std::function对象</span>
func <span class="token operator">=</span> simpleFunction<span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Called simpleFunction with 10"</span>

<span class="token comment" spellcheck="true">// 使用lambda表达式</span>
func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Called lambda with "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Called lambda with 20"</span>

<span class="token comment" spellcheck="true">// 将成员函数转换为可调用对象，并通过std::bind绑定this指针</span>
MyClass <span class="token class-name">obj</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> boundMemberFunc <span class="token operator">=</span>       std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>MyClass<span class="token operator">::</span>memberFunction<span class="token punctuation">,</span> <span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundMemberFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 "Called memberFunction with 30"</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p>上述代码展示了如何使用 <code>std::function</code> 存储不同类型和来源的可调用对象，并在需要的时候调用它们。<code>std::function</code> 具有延迟计算的特点，非常适合在事件处理、回调机制、策略模式等场景下使用。</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>

<span class="token keyword">void</span> <span class="token function">printString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Print: "</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span> printer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义一个可调用对象包装器</span>

<span class="token comment" spellcheck="true">// 将全局函数赋值给std::function对象</span>
printer <span class="token operator">=</span> printString<span class="token punctuation">;</span>
<span class="token function">printer</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用printString函数</span>

<span class="token comment" spellcheck="true">// 使用Lambda表达式</span>
printer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Lambda says: "</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token function">printer</span><span class="token punctuation">(</span><span class="token string">"Hello from Lambda!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>在这个示例中，<code>std::function&lt;void(const std::string&amp;)&gt;</code> 可以存储任何接受一个<code>const std::string&amp;</code>参数且没有返回值的可调用对象。通过改变赋给它的可调用实体，我们可以动态地改变行为。</p>
</blockquote>
<h5 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a><strong>智能指针</strong></h5><p>C++11标准引入了三种智能指针来协助管理和自动释放动态分配的对象，分别是<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。这些智能指针通过RAII（Resource Acquisition Is Initialization）原则确保了资源在适当的时间得到释放，从而有效防止内存泄漏等问题。</p>
<ol>
<li><p><strong>std::unique_ptr</strong></p>
<ul>
<li><p><code>std::unique_ptr</code> 是独占所有权的智能指针，同一时刻只有一个<code>unique_ptr</code>指向某个动态分配的对象。当<code>unique_ptr</code>超出其作用域或被重新赋值时，它会自动释放所指向的对象，确保了内存的有效回收。</p>
</li>
<li><p><code>unique_ptr</code> 不支持拷贝构造和赋值操作，只能移动（move），这就意味着所有权不能被复制，只能转移。</p>
</li>
<li><p>示例：</p>
<pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> <span class="token function">uptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>std::shared_ptr</strong></p>
<ul>
<li><p><code>std::shared_ptr</code> 实现了共享所有权，多个<code>shared_ptr</code>可以同时指向同一个动态分配的对象。对象的生命周期由所有指向它的<code>shared_ptr</code>共同维护，只要至少有一个<code>shared_ptr</code>存在，对象就不会被释放。</p>
</li>
<li><p><code>shared_ptr</code> 内部使用引用计数机制，每当创建一个新的<code>shared_ptr</code>引用同一对象时，引用计数加1；当<code>shared_ptr</code>被销毁或赋值给另一个对象时，引用计数减1。当引用计数降为0时，对象会被自动释放。</p>
</li>
<li><p><code>shared_ptr</code> 支持拷贝构造、赋值和移动操作。</p>
</li>
<li><p>示例：</p>
<pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> <span class="token function">sptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> sptr2 <span class="token operator">=</span> sptr1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 共享同一对象</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>std::weak_ptr</strong></p>
<ul>
<li><p><code>std::weak_ptr</code> 是一种不增加引用计数的智能指针，它用来观察由<code>shared_ptr</code>管理的对象，但并不参与对象的生命周期管理。<code>weak_ptr</code>不能单独使用，必须先通过调用<code>lock()</code>方法获取一个临时的<code>shared_ptr</code>来访问对象，如果对象已经不存在（所有<code>shared_ptr</code>都不再引用它），<code>lock()</code>会返回一个空的<code>shared_ptr</code>。</p>
</li>
<li><p><code>weak_ptr</code> 主要用于解决循环引用问题，防止对象在不再需要时仍然因为循环引用而无法释放。</p>
</li>
<li><p>示例：</p>
<pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> <span class="token function">sptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> <span class="token function">wptr</span><span class="token punctuation">(</span>sptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyClass<span class="token operator">></span> locked <span class="token operator">=</span> wptr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 对象依然存在，可以安全访问</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 对象已经被释放</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<p>总的来说，C++11智能指针通过自动化的内存管理，极大地提高了程序的安全性和健壮性。开发人员只需关注业务逻辑，而不用过多关心内存的细节。此外，根据实际需求合理选择适合的智能指针类型，能够有效地降低代码出错的可能性，并提高程序性能。</p>
<h5 id="make-shared和shared-ptr"><a href="#make-shared和shared-ptr" class="headerlink" title="make_shared和shared_ptr"></a>make_shared和shared_ptr</h5><p><code>std::make_shared</code> 和 <code>std::shared_ptr</code> 是 C++11 标准库中智能指针部分的相关工具。它们之间的关系密切，但是有着不同的功能和目的：</p>
<ol>
<li><p><strong>std::shared_ptr</strong>：</p>
<ul>
<li><p><code>std::shared_ptr</code> 是一个智能指针类，它实现了引用计数的共享所有权模型。当你创建一个 <code>shared_ptr</code> 对象时，它会自动管理所指向对象的生命周期——当最后一个 <code>shared_ptr</code> 不再引用该对象时，对象会被自动删除，避免了内存泄漏的问题。</p>
</li>
<li><p>通常情况下，创建一个 <code>shared_ptr</code> 需要显式地调用构造函数，传入指向动态分配对象的原始指针：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> MyObject <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyObject<span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>std::make_shared</strong>：</p>
<ul>
<li><p><code>std::make_shared</code> 是一个工厂函数，用于高效地创建一个 <code>std::shared_ptr</code> 实例以及它所指向的对象。它在一个步骤中完成内存分配和智能指针初始化，相较于直接使用 <code>new</code> 和 <code>shared_ptr</code> 构造函数，<code>make_shared</code> 有一些优势：</p>
<ul>
<li>内存优化：<code>make_shared</code> 只做一次内存分配，将智能指针的控制块（管理引用计数等信息）和对象本身分配在同一块连续内存中，降低了内存碎片和额外开销。</li>
<li>一致性和安全性：在多线程环境下，<code>make_shared</code> 创建的 <code>shared_ptr</code> 对象在初始化过程中更具原子性，减少了潜在的数据竞争问题。</li>
<li>更简洁的语法：它可以直接用于创建并初始化对象，减少了代码量。</li>
</ul>
<p>使用 <code>std::make_shared</code> 的示例：</p>
<p>Cpp</p>
<pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyObject<span class="token operator">></span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyObject<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<p>总的来说，<code>std::make_shared</code> 是为了更安全、高效地创建 <code>std::shared_ptr</code> 而提供的便捷工具函数，它强化了 <code>shared_ptr</code> 的使用体验，并且在性能和内存管理上做了优化。在实际编码中，除非有特殊理由，通常建议优先使用 <code>std::make_shared</code> 来创建 <code>shared_ptr</code>。</p>
<h5 id="为什么C-11摒弃了auto-ptr"><a href="#为什么C-11摒弃了auto-ptr" class="headerlink" title="为什么C++11摒弃了auto_ptr?"></a>为什么C++11摒弃了auto_ptr?</h5><p>C++11标准废弃<code>std::auto_ptr</code>主要是由于以下几个原因：</p>
<ol>
<li><strong>所有权转移</strong>： <code>std::auto_ptr</code>的设计初衷是提供一个自动管理资源（特别是动态分配内存）的智能指针，但其拷贝和赋值操作会导致所有权的转移而非共享。这意味着每次拷贝或赋值操作都会使原有<code>auto_ptr</code>变得无效（指向NULL），这与大多数程序员对普通指针拷贝操作的预期不符，容易引发错误。</li>
<li><strong>不支持容器</strong>： <code>std::auto_ptr</code>不遵守STL容器的元素要求，因为它违反了CopyConstructible和Assignable的要求。由于所有权转移的特性，将<code>auto_ptr</code>放入容器（如<code>std::vector</code>或<code>std::map</code>）会导致容器内部元素的状态发生意外变化，从而引起未定义行为甚至内存泄漏。</li>
<li><strong>不支持数组</strong>： <code>std::auto_ptr</code>不能用于管理动态分配的数组，因为其析构函数只会调用单个对象的删除器，而不是适用于数组的删除器。</li>
<li><strong>线程安全性</strong>： <code>std::auto_ptr</code>并未提供线程安全的引用计数，这意味着在多线程环境中使用它可能会导致竞态条件和未知的行为。</li>
<li><strong>与C++11新特性的不兼容性</strong>： C++11引入了右值引用和移动语义，这两个新特性使得能够更好地设计和实现智能指针。相比之下，<code>std::auto_ptr</code>基于旧有的C++98标准设计，未能充分利用这些新特性。</li>
</ol>
<p>鉴于上述问题，C++11引入了两个新的智能指针类型来取代<code>std::auto_ptr</code>：</p>
<ul>
<li><code>std::unique_ptr</code>：它同样具有独占所有权，但其设计符合C++11的标准要求，支持移动语义而不支持拷贝，解决了所有权转移带来的问题，并且可以用于管理动态分配的数组。</li>
<li><code>std::shared_ptr</code>：它支持共享所有权，通过引用计数来决定何时释放资源，可以用于容器，并且在多线程环境下的使用相对安全。</li>
</ul>
<h5 id="什么是右值引用"><a href="#什么是右值引用" class="headerlink" title="什么是右值引用?"></a>什么是右值引用?</h5><p>右值引用是C++11引入的新特性，它允许对即将销毁的临时对象进行高效的资源管理。右值引用记作 <code>T&amp;&amp;</code>，其中 <code>T</code> 是类型名。</p>
<p>在C++中，值可以分为左值（lvalue）和右值（rvalue）两类。左值是可以持久存在的，有名称的，可以出现在赋值操作符左侧的表达式，比如变量。右值则是临时的、无名的、不能取地址的表达式，比如临时对象、函数返回值、字面量等。右值引用就是为了绑定到右值而设计的引用类型。</p>
<p>右值引用的主要特点和用途包括：</p>
<ol>
<li><strong>移动语义（Move Semantics）</strong>： 当我们将一个右值引用绑定到一个即将销毁的临时对象上时，可以通过移动构造函数或移动赋值运算符将临时对象的资源“偷走”（move），而非进行代价高昂的复制操作。这样既节省了资源，又提高了效率。</li>
<li><strong>完美转发（Perfect Forwarding）</strong>： 在模板编程中，右值引用可以帮助实现完美的函数参数转发，使得函数能够透明地处理其参数无论是左值还是右值的情况，进而设计出更通用和高效的函数模板。</li>
<li><strong>转移所有权</strong>： 在资源管理领域，如智能指针等类库设计中，右值引用可以用来实现资源所有权的高效转移，避免了不必要的拷贝操作。</li>
</ol>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 移动构造函数</span>
    <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 移动资源</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        other<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 清理原对象的资源</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Data<span class="token operator">></span> data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 假设data是一个独占资源</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

MyClass <span class="token class-name">CreateInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> MyClass<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* ... */</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回的是一个临时对象，即右值</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        MyClass <span class="token class-name">obj</span> <span class="token operator">=</span> <span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用移动构造函数，高效地转移资源</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>在这个例子中，<code>CreateInstance()</code> 函数返回的临时对象就是一个右值，而 <code>MyClass obj = CreateInstance();</code> 中的 <code>=</code> 运算符通过调用移动构造函数，将临时对象的资源转移给了 <code>obj</code>，避免了深拷贝。</p>
<h5 id="emplace-back和push-back的区别"><a href="#emplace-back和push-back的区别" class="headerlink" title="emplace_back和push_back的区别?"></a>emplace_back和push_back的区别?</h5><p><code>std::vector</code>容器（以及其他类似容器如<code>std::deque</code>等）中的<code>push_back</code>和<code>emplace_back</code>函数均用于向容器末尾添加元素，但它们在工作方式和效率上有显著区别：</p>
<ol>
<li><p>**push_back()**：</p>
<ul>
<li><p><code>push_back</code>函数接受一个元素的副本作为参数，然后将这个副本添加到容器的末尾。</p>
</li>
<li><p>当传递给<code>push_back</code>的是一个<strong>用户自定义类型</strong>（非POD类型）时，如果容器内元素不是小型对象优化（SOO）的候选者，通常会发生两次构造过程：首先调用构造函数创建参数副本，然后在容器内部再次调用构造函数（可能是拷贝构造函数或移动构造函数）将副本添加到容器中。</p>
<pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>
vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 字符串会被拷贝或移动到vec中</span>
</code></pre>
</li>
</ul>
</li>
<li><p>**emplace_back()**：</p>
<ul>
<li><p><code>emplace_back</code>函数接受的是构造元素所需的一组参数，它会直接在容器内部调用元素类型的构造函数来创建元素，而不是先创建一个副本再插入。</p>
</li>
<li><p>使用<code>emplace_back</code>可以避免不必要的拷贝或移动操作，尤其当元素构造成本较高或者不支持移动构造时，这种方法更为高效。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Person <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Person<span class="token operator">></span> people<span class="token punctuation">;</span>
people<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接在容器内部构造Person对象</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong><code>emplace_back</code>相比<code>push_back</code>更适合于直接构造元素的情况，可以减少临时对象的创建和销毁，提高代码性能</strong>。尤其是在大型结构体、类对象等非基本类型的情况下，利用<code>emplace_back</code>可以更好地利用C++11及后续版本引入的完美转发和移动语义等特性。不过，在实际使用中也需要根据具体情况进行权衡，例如对于内置类型或者小对象，两者的效率差异可能不大。</p>
<h4 id="3-3submitTask-的实现"><a href="#3-3submitTask-的实现" class="headerlink" title="3.3submitTask()的实现"></a>3.3submitTask()的实现</h4><p>submitTask()函数作用: 外部用户想使用线程池会通过线程池对象pool调用submitTask()函数向线程池提交任务,如pool.submitTask().</p>
<p>线程池里使用继承和多态思想设计了通用抽象基类Task(), 派生类是用户根据基类Task()实现的具体任务, 从而实现提交不同类型任务功能.</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//5. 给线程池提交任务  用户调用该接口，传入用户对象，生产任务</span>
Result ThreadPool<span class="token operator">::</span><span class="token function">submitTask</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>sp<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//智能指针指向从基类task派生来的用户提交的具体task对象</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//1.获取锁  用户提交任务生产者，线程执行任务消费者，为保证线程安全，使用互斥锁</span>
std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抢到锁就可以向任务队列放任务</span>

<span class="token comment" spellcheck="true">//2.线程的通信  等待任务队列有空余  </span>
<span class="token comment" spellcheck="true">// wait:一直等lambda函数条件满足 wait_for：有时间参数，最多等一段时间 wait_until：有时间参数，设置了等待节点</span>

<span class="token comment" spellcheck="true">/*
while (taskQue_.size() == taskQueMaxThreshold_)
&amp;#123;
notFull_.wait(lock);
&amp;#125;
*/</span>

<span class="token comment" spellcheck="true">//用户提交爱任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span>
<span class="token comment" spellcheck="true">//查看任务队列是否满，如果满了，条件变量阻塞住，同时释放锁，不释放锁的话线程无法消费任务。</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>notFull_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>taskQueMaxThreshold_<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//“&amp;”的作用，lamda函数访问外部成员变量，需要变量捕获 ，引用捕获</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//表示notfull_等待1s钟，条件仍然为满足</span>
std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"task queue is full ,submit task fail."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">Result</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Task  Result</span>
<span class="token comment" spellcheck="true">//return task->getResult(); 不能用这种方式返回，线程执行完task，task对象就被析构掉了</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//3.如果有空余，把任务放入任务队列中</span>
taskQue_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
taskSize_<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//4.因为新放了任务，任务队列肯定不为空了，在notEmpty_上进行通知.赶快分配线程执行任务</span>
notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通知线程池消费</span>

<span class="token comment" spellcheck="true">//cached模式 任务处理比较紧急 场景：小而快的任务 需要根据线程数量和空闲线程的数量，判断是否需要创建新的线程出来？</span>
     <span class="token comment" spellcheck="true">//耗时任务多不适合cached模式，因为耗时的任务会长时间占用一个线程，耗时任务比较多会导致线程池创建线程过多，</span>
         <span class="token comment" spellcheck="true">//创建线程过多会对系统性能影响非常大</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>poolMode_<span class="token operator">==</span>PoolMode<span class="token operator">::</span>MODE_CACHED
<span class="token operator">&amp;&amp;</span>taskSize_<span class="token operator">></span>idleThreadSize_
<span class="token operator">&amp;&amp;</span> curThreadSize_<span class="token operator">&lt;</span>threadSizeThreshHold_<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">">>>> create new thread...."</span>  <span class="token operator">&lt;&lt;</span> <span class="token string">"exit!"</span>
 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//创建新的线程对象</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Thread<span class="token operator">></span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ThreadPool<span class="token operator">::</span>threadFunc<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//threads_.emplace_back(std::move(ptr));</span>
<span class="token keyword">int</span> threadId <span class="token operator">=</span> ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
threads_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>threadId<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//启动线程</span>
threads_<span class="token punctuation">[</span>threadId<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">//修改线程个数相关的变量</span>
curThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


<span class="token comment" spellcheck="true">//返回任务的Result对象</span>
<span class="token comment" spellcheck="true">//return task->getResult();</span>
<span class="token keyword">return</span> <span class="token function">Result</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><img src="https://gcdnb.pbrd.co/images/lsZzpriKIzAG.png?o=1"></p>
<h4 id="3-4-Any类型-线程池返回任意类型结果"><a href="#3-4-Any类型-线程池返回任意类型结果" class="headerlink" title="3.4 Any类型 线程池返回任意类型结果"></a>3.4 Any类型 线程池返回任意类型结果</h4><p>有些任务需要线程执行结束后返回给用户结果, 用户提交的任务不一样相应的会有不同的返回值</p>
<p>如何设计返回值类型? 用模板T? 不能使用模板</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//任务抽象基类</span>
<span class="token keyword">class</span> <span class="token class-name">Task</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">//用户可以自定义任意任务类型,从Task继承, 重写run方法,实现自定义任务处理</span>
<span class="token keyword">virtual</span> T <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//代码从上向下编译,看到虚函数,会给Task类产生虚函数表,将虚函数的地址记录到虚函数表里,T模板类型,并没有实例化,找不到函数地址.virtual虚函数不能和T函数模板放一起用</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>如何构建一个Any类型?</strong></p>
<ul>
<li>任意的其他类型 <strong>template</strong></li>
<li>能让一个类型 指向 其他任意的类型呢?  <strong>基类类型指向派生类类型</strong></li>
</ul>
<p><img src="https://gcdnb.pbrd.co/images/zSrPsK7SXrZO.png?o=1"></p>
<p>Any &#x3D;&gt; Base*——&gt;  Derive: public Base</p>
<p>1.Any类型的成员是基类指针Base* 因为只有基类指针可以指向不同的派生类对象.</p>
<p>2.让基类指针指向从基类继承来的派生类对象Derive.</p>
<p>3.data直接返回为Any不行,Any是基类指针, 只有将data作为派生类Derive的成员变量.</p>
<p>4.data是什么类型?不知道,因为用户会有不同的任务,需要template模板定义data的类型.</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//run()函数返回值如何实现? 可以表示任意的类型</span>
<span class="token comment" spellcheck="true">//Java Python 都有Object类型 是所有其他类类型的基类</span>
<span class="token comment" spellcheck="true">//C++17 Any类型</span>
Any <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tid: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"begin!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//this_thread::sleep_for(chrono::seconds(2));</span>
ULong sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>ULong i <span class="token operator">=</span> begin_<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end_<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tid: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span><span class="token string">"end!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>Any类型的实现</strong></p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Any类型:可以接收任意数据的类型</span>
<span class="token keyword">class</span> <span class="token class-name">Any</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认构造</span>
<span class="token operator">~</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认析构</span>

<span class="token comment" spellcheck="true">//成员变量data_已经禁止了左值引用的拷贝构造和赋值,当前对象肯定也不能左值引用拷贝构造和赋值</span>
<span class="token function">Any</span><span class="token punctuation">(</span><span class="token keyword">const</span> Any<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
Any<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Any<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token function">Any</span><span class="token punctuation">(</span>Any<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认右值引用的成员变量拷贝构造</span>
Any<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Any<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认右值引用的成员变量赋值</span>

<span class="token comment" spellcheck="true">//这个构造函数可以让Any接受任意其他类型的数据</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token function">Any</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">base_</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Derive<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模板的代码，为什么声明不写在头文件，定义写在源文件，而是定义声明都写在头文件中</span>
<span class="token comment" spellcheck="true">//只能写在头文件中，编译阶段才能实例化，实例化后才能产生真真正正的函数。</span>

<span class="token comment" spellcheck="true">//这个方法能把Any对象里面存储的data数据提取出来</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
T <span class="token function">cast_</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//怎么从base_找到他所指向的Derive对象,从它里面提出data成员变量</span>
<span class="token comment" spellcheck="true">//基类指针=>转成派生类指针  RTTI类型识别 C++四种类型强转</span>
Derive<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> pd<span class="token operator">=</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Derive<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>base_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pd <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token string">"type is unmatch!"</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pd<span class="token operator">-</span><span class="token operator">></span>data_<span class="token punctuation">;</span> 
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">//基类类型</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//派生类类型</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Derive</span><span class="token operator">:</span><span class="token keyword">public</span> Base
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Derive</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
T data_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存了任意的其他类型</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">//定义一个基类的指针Base *  用于指向派生类对象</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Base<span class="token operator">></span>base_<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//unique_ptr将左值引用的拷贝构造和赋值禁用了,公布了右值引用的拷贝构造和赋值</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>Derive<T>* pd&#x3D;dynamic_cast&lt;Derive<T>*&gt;(base_.get());解释</strong></p>
<p>C++中智能指针<code>std::unique_ptr&lt;Base&gt;</code>类型的对象<code>base_</code>进行动态类型转换，并试图将其转换为指向派生类<code>Derive&lt;T&gt;</code>类型的智能指针。</p>
<p><code>std::unique_ptr&lt;Base&gt;</code>是一个持有<code>Base</code>类类型或其派生类对象的智能指针。<code>base_.get()</code>返回的是智能指针内部存储的原始指针。</p>
<p><code>dynamic_cast&lt;Derive&lt;T&gt;*&gt;(base_.get())</code> 这一行代码的含义是：</p>
<ol>
<li><code>dynamic_cast</code>: 这是C++中的动态类型转换操作符，它用于安全地在类层次结构中进行向下转型。如果<code>base_</code>所指向的对象实际上是一个<code>Derive&lt;T&gt;</code>类型的实例，或者<code>Derive&lt;T&gt;</code>是<code>Base</code>的派生类，那么这个转换就会成功，并返回一个指向<code>Derive&lt;T&gt;</code>对象的指针。</li>
<li><code>&lt;Derive&lt;T&gt;*&gt;</code>: 指定转换的目标类型，这里是将<code>Base</code>类型的指针转换为<code>Derive&lt;T&gt;</code>类型的指针。</li>
<li><code>base_.get()</code>: 获取<code>std::unique_ptr&lt;Base&gt;</code>所拥有的原始<code>Base</code>类型的指针，以便进行类型转换。注意，<code>get()</code>方法返回的是裸指针，转换的结果仍需存储回一个智能指针中以保持资源的自动管理。</li>
</ol>
<p>转换后的结果<code>Derive&lt;T&gt;* pd</code>是一个指向<code>Derive&lt;T&gt;</code>对象的指针，若转换失败（即<code>base_</code>所指向的对象并非<code>Derive&lt;T&gt;</code>或其派生类实例），<code>pd</code>将为<code>nullptr</code>。</p>
<p>但是要注意，如果要将转换后的指针存储回一个智能指针，应该创建一个对应的<code>std::unique_ptr&lt;Derive&lt;T&gt;&gt;</code>来接管该指针的生命周期管理，例如：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>Derive<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Derive<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>base_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Derive<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">derivedPd</span><span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确地接管转换后指针的生命周期管理</span>
    <span class="token comment" spellcheck="true">// 现在可以安全地使用derivedPd</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 转换失败，base_所指向的对象不是一个Derive&lt;T>实例</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//问题二：如何设计Result机制呢</span>
    Result res1 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyTask<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果线程还没执行完,用户调用get()函数返回,应该阻塞;</span>
</code></pre>
</blockquote>
<p>res.get()返回Any类型, 那么如何从Any类型提取用户需要的类型呢?</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> sum <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cast_<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//get返回一个Any类型,怎么转成具体的类型呢?</span>
</code></pre>
</blockquote>
<h5 id="C-11四种强制类型转换"><a href="#C-11四种强制类型转换" class="headerlink" title="C++11四种强制类型转换?"></a>C++11四种强制类型转换?</h5><p>在C++11中，为了增强类型转换的安全性和表达意图的清晰度，引入了四种强制类型转换操作符，分别是<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>和<code>reinterpret_cast</code>。每种转换都有其特定的应用场景和限制。</p>
<ol>
<li><p><strong>static_cast</strong>：</p>
<ul>
<li><p>用途：主要用于静态类型转换，包括底层类型之间的转换（如int转double）、指针或引用类型之间的转换（如父类指针转子类指针，前提是存在继承关系并且向下转型是安全的），以及枚举类型与整数类型的相互转换。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将double转换为int，可能会丢失精度</span>
Base<span class="token operator">*</span> basePtr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Derived<span class="token operator">*</span> derivedPtr <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>basePtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 向下转型，仅当basePtr实际指向Derived对象时才安全</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>const_cast</strong>：</p>
<ul>
<li><p>用途：唯一用于修改表达式中常量属性的转换，它可以去除指针或引用的const、volatile限定符，但并不能改变对象的实际内容。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> cptr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将非const指针转换为const指针，但不能通过此指针修改值</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>dynamic_cast</strong>：</p>
<ul>
<li><p>用途：用于运行时类型识别和安全的向下转型，适用于类层次结构中的指针和引用。如果试图将一个父类指针转换为子类指针，但实际指向的对象并非子类实例，则转换结果为nullptr（对于指针）或抛出std::bad_cast异常（对于引用）。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

Base<span class="token operator">*</span> basePtr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Derived<span class="token operator">*</span> derivedPtr <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>basePtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 安全向下转型，这里derivedPtr将是有效的</span>
Base<span class="token operator">*</span> anotherBasePtr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Derived<span class="token operator">*</span> failedCast <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>anotherBasePtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里failedCast将为nullptr</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>reinterpret_cast</strong>：</p>
<ul>
<li><p>用途：用于低级别的比特级转换，它允许几乎任何指针类型间的转换，以及整数类型和足够大的指针类型之间的转换。这种转换通常用于操纵底层二进制表示，是危险的操作，如果没有充分的理由，一般应避免使用。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span> cp <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将int指针转换为char指针，操作底层内存</span>
<span class="token keyword">long</span><span class="token operator">*</span> lp <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 风险操作，将char*转换回long*</span>
<span class="token number">4</span><span class="token comment" spellcheck="true">// 注意：这种转换依赖于底层平台的内存对齐和字节序，通常不适合跨类型数据交换</span>

    <span class="token comment" spellcheck="true">//C++11的四种强制类型转换各有侧重，开发者应谨慎使用，尽量在确保类型转换安全和有意义的前提下进行转换，避免引入难以察觉的bug和未定义行为。</span>
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="3-5-Result及semaphore的实现"><a href="#3-5-Result及semaphore的实现" class="headerlink" title="3.5 Result及semaphore的实现"></a>3.5 Result及semaphore的实现</h4><p>应用背景: </p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//问题二：如何设计Result机制呢</span>
Result res1 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyTask<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果线程还没执行完,用户调用get()函数返回,应该阻塞;</span>
</code></pre>
<p>Result用于接收线程执行完任务的结果, 如果线程还未执行完, 用户调用get()方法应该阻塞, 等任务结束, 通过信号量通知,get()继续执行并返回结果.</p>
<p>信号通信使用到信号量semaphore, 在C++20已经有了定义, 现在自己实现semaphore.</p>
</blockquote>
<p><strong>重点: 线程的同步</strong></p>
<p><strong>线程互斥:</strong> mutex 基于CAS的原子类型atomic 例如data++,data–</p>
<p>mutex: 互斥锁是一个比较重的锁会改变线程的状态</p>
<p>CAS:相当于给总线加锁,以原子操作做了一个寄存器,跟内存的交换,并不会改变线程的状态</p>
<p>在C++中，基于CAS（Compare and Swap）的原子类型主要体现在<code>std::atomic</code>模板类中。<code>std::atomic</code>是C++11及更高版本引入的标准库的一部分，主要用于在多线程环境下提供原子操作的支持，尤其是针对那些需要无锁同步的场景。</p>
<p><code>std::atomic</code>通过底层硬件指令（如Intel的<code>cmpxchg</code>指令或AMD的相应指令）实现了CAS操作，允许程序员在不使用互斥锁的情况下安全地修改共享数据。当一个线程尝试修改<code>std::atomic</code>类型的变量时，它会先比较当前值是否与期望值相匹配，如果匹配，则将变量设置为新的值。这一过程是原子的，意味着不会有其他线程可以在比较和交换这两个步骤之间干扰。</p>
<p>CAS在C++中的典型用处包括但不限于：</p>
<ol>
<li><strong>无锁数据结构</strong>: 可以构建无锁栈、队列或其他数据结构，其中元素的添加、删除或更新操作通过CAS来实现，减少因锁定而导致的线程阻塞和上下文切换。</li>
<li><strong>计数器</strong>: 使用<code>std::atomic&lt;int&gt;</code>作为线程安全的计数器，例如统计事件次数、引用计数等，多个线程可以同时递增或递减计数器而无需担心数据竞争。</li>
<li><strong>线程间同步</strong>: 可以实现高效的自旋锁和其他轻量级同步原语，例如原子地改变某个标志位来协调线程间的活动。</li>
<li><strong>避免死锁</strong>: 由于不需要传统的互斥锁，因此可以避免死锁的发生，尤其是在复杂的多线程系统中。</li>
</ol>
<p><strong>线程通信:</strong> 条件变量(condition_variable)+信号量(semaphore)</p>
<h5 id="3-5-1实现一个sempaphore类"><a href="#3-5-1实现一个sempaphore类" class="headerlink" title="3.5.1实现一个sempaphore类"></a>3.5.1实现一个sempaphore类</h5><blockquote>
<pre class=" language-cpp"><code class="language-cpp">calss Semaphore<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token operator">:</span><span class="token function">resLimit_</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span>
  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">~</span><span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//获取一个信号量资源  //操作系统的pv操作</span>
<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token function">lock</span><span class="token punctuation">(</span>mtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//等待信号量资源没有资源的话,阻塞当前线程</span>
  <span class="token function">cond_wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> resLimit_<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  resLimit<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//增加一个信号量资源</span>
<span class="token keyword">void</span> <span class="token function">post</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token function">lock</span><span class="token punctuation">(</span>mtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  resLimit_<span class="token operator">++</span><span class="token punctuation">;</span>
  cond_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token keyword">int</span> resLimit_<span class="token punctuation">;</span>
std<span class="token operator">::</span>mutux mtx_<span class="token punctuation">;</span>
std<span class="token operator">::</span>conditon_variable cond_<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h5 id="3-5-2实现Result"><a href="#3-5-2实现Result" class="headerlink" title="3.5.2实现Result"></a>3.5.2实现Result</h5><p>实现接收提交到线程池的task任务执行完成后返回的返回值类型Result;</p>
<p>用户提交任务的线程和任务执行的线程并不是一个线程 , 需要进行线程通信机制</p>
<p><strong>Result类设计</strong></p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Task类型的前置声明</span>
<span class="token keyword">class</span> <span class="token class-name">Task</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//实现接收提交到线程池的task任务执行完成后返回的返回值类型Result;</span>
<span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    
<span class="token keyword">public</span><span class="token operator">:</span>

<span class="token function">Result</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>task<span class="token punctuation">,</span><span class="token keyword">bool</span> isValid<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">~</span><span class="token function">Reslut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//智能指针管理,析构函数不必做事,设置为默认;</span>
<span class="token comment" spellcheck="true">// 问题一： setVal方法，获取任务执行完的返回值的</span>
<span class="token keyword">void</span> <span class="token function">setVal</span><span class="token punctuation">(</span>Any any<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//问题二：  get方法  用户调用这个方法获取task的返回值</span>
Any <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>

Any any_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存储任务的返回值</span>
Semaphore sem_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//线程通信信号量</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>task_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向对应获取返回值的任务对象,因为task执行完成后会被析构,要想拿到task的返回值</span>
                        <span class="token comment" spellcheck="true">//需要使用智能指针将task绑定到Result对象,防止task提前析构.</span>
std<span class="token operator">::</span>atomic_bool isValid_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回值是否有效  如果用户提交任务失败,返回值肯定无效</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//4.任务抽象基类</span>
<span class="token keyword">class</span> <span class="token class-name">Task</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">~</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">setResult</span><span class="token punctuation">(</span>Result<span class="token operator">*</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 用户可以自定义任意任务类型，从task继承，重写run方法，实现自定义任务处理</span>
<span class="token keyword">virtual</span> Any <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
Result <span class="token operator">*</span> result_<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//Result对象的生命周期强于Task  不能使用智能指针会与Task发生交叉引用</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p><strong>Result方法的实现</strong></p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//////////////////////   Task方法实现</span>
Task<span class="token operator">::</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">:</span><span class="token function">result_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> Task<span class="token operator">::</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>result_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  result_<span class="token operator">-</span><span class="token operator">></span><span class="token function">setVal</span><span class="token punctuation">(</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里发生多态调用；</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> Task<span class="token operator">::</span><span class="token function">setResult</span><span class="token punctuation">(</span>Result<span class="token operator">*</span> res<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
result_ <span class="token operator">=</span> res<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

Result<span class="token operator">::</span><span class="token function">Result</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>task<span class="token punctuation">,</span><span class="token keyword">bool</span> isValid<span class="token punctuation">)</span>
<span class="token operator">:</span><span class="token function">isValid_</span><span class="token punctuation">(</span>isvalid<span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">task_</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//task_是强智能指针,task_的引用计数不为零task_不会被析构</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/////////////////////   Result方法的实现</span>
Result<span class="token operator">::</span><span class="token function">Result</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>task<span class="token punctuation">,</span> <span class="token keyword">bool</span> isValid <span class="token punctuation">)</span>
<span class="token operator">:</span><span class="token function">isValid_</span><span class="token punctuation">(</span>isValid<span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">task_</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
task_<span class="token operator">-</span><span class="token operator">></span><span class="token function">setResult</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
Any Result<span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//用户调用的</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isValid_<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
sem_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//task任务如果没有执行完，这里会阻塞用户的线程</span>
<span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>any_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//Any类中的any_是unique_ptr类型的 右值禁止拷贝，使用move();</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> Result<span class="token operator">::</span><span class="token function">setVal</span><span class="token punctuation">(</span>Any any<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//存储task的返回值</span>
<span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>any_ <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//any禁用左值的拷贝构造和赋值,因为消耗很大,使用move做资源转移</span>
sem_<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//已经获取了任务的返回值，增加信号量资源</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h4 id="3-6-Cached模式设计实现"><a href="#3-6-Cached模式设计实现" class="headerlink" title="3.6 Cached模式设计实现"></a>3.6 Cached模式设计实现</h4><p>1.用户在使用线程池时候可以自己设计线程模式 setMode()方法</p>
<p>2.需要根据任务数量和空闲线程数量,判断是否需要创建新的线程出来?</p>
<p>3.catched模式下,有可能已经创建了很多的线程,但是空闲时间超过60s, 应该把多余的线程结束回收掉</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp">          <span class="token comment" spellcheck="true">//cached模式 任务处理比较紧急 场景：小而快的任务 需要根据线程数量和空闲线程的数量，判断是否需要创建新的线程出来？</span>
          <span class="token comment" spellcheck="true">//耗时任务多不适合cached模式，因为耗时的任务会长时间占用一个线程，耗时任务比较多会导致线程池创建线程过多，</span>
          <span class="token comment" spellcheck="true">//创建线程过多会对系统性能影响非常大</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>poolMode_<span class="token operator">==</span>PoolMode<span class="token operator">::</span>MODE_CACHED
  <span class="token operator">&amp;&amp;</span>taskSize_<span class="token operator">></span>idleThreadSize_
  <span class="token operator">&amp;&amp;</span> curThreadSize_<span class="token operator">&lt;</span>threadSizeThreshHold_<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">">>>> create new thread...."</span>  <span class="token operator">&lt;&lt;</span> <span class="token string">"exit!"</span>
      <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">//创建新的线程对象</span>
  std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Thread<span class="token operator">></span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ThreadPool<span class="token operator">::</span>threadFunc<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//threads_.emplace_back(std::move(ptr));</span>
  <span class="token keyword">int</span> threadId <span class="token operator">=</span> ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  threads_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>threadId<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//启动线程</span>
  threads_<span class="token punctuation">[</span>threadId<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">//修改线程个数相关的变量</span>
  curThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
  idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

</code></pre>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程回收掉</span>
      <span class="token comment" spellcheck="true">//结束回收掉？(超过initThreadSize_数量的线程要进行回收)</span>
      <span class="token comment" spellcheck="true">//当前时间-上一次线程执行的时间 > 60s</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>poolMode_ <span class="token operator">==</span> PoolMode<span class="token operator">::</span>MODE_CACHED<span class="token punctuation">)</span>
      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//每一秒钟返回一次    怎么区分：超时返回？ 还是有任务待执行返回</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
              <span class="token comment" spellcheck="true">//条件变量，超时返回了</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cv_status<span class="token operator">::</span>timeout <span class="token operator">==</span>
                  notEmpty_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                  <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">auto</span> dur <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>seconds<span class="token operator">></span><span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>dur<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> THREAD_MAX_IDLE_TIME
                      <span class="token operator">&amp;&amp;</span> curThreadSize_<span class="token operator">></span>initThreadSize_<span class="token punctuation">)</span>
                  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                      <span class="token comment" spellcheck="true">//开始回收当前线程</span>
                      <span class="token comment" spellcheck="true">//记录线程数量的相关变量的值修改</span>
                      <span class="token comment" spellcheck="true">//把线程对象从线程列表容器中删除   没有办法 threadFunc   匹配哪个thread对象</span>
                      <span class="token comment" spellcheck="true">//threadid => thread对象 => 删除</span>
                      threads_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>threadid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//std::this_thread::getid()</span>
                      curThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>
                      idleThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>

                      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"exit!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
                      <span class="token keyword">return</span><span class="token punctuation">;</span>
                  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h4 id="3-7-线程池资源回收"><a href="#3-7-线程池资源回收" class="headerlink" title="3.7 线程池资源回收"></a>3.7 线程池资源回收</h4><p>ThreadPool对象析构以后,怎么样把线程池相关线程资源全部回收?</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//2. 线程池析构     C++中只要出现了构造一定要有析构</span>
ThreadPool<span class="token operator">::</span><span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
isPoolrunning_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//通知线程从等待状态到阻塞状态,然后才能抢锁</span>
notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//等待线程池里面所有的线程返回  有两种状态： 阻塞 &amp; 正在执行任务中</span>
std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//继续析构的前提是线程容器里的线程对象清空了threads_.size() == 0,如果还有线程对象说明有线程未被回收,线程池先不析构</span>
exitCond_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> threads_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isPoolRunning_<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
threads_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>threadid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// std::this_thread::getid()</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" exit!"</span>
<span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
exitCond_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结束线程函数，就是结束当前线程了!</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h3 id="4-Thread类设计"><a href="#4-Thread类设计" class="headerlink" title="4.Thread类设计"></a>4.Thread类设计</h3><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//线程类型</span>
<span class="token keyword">class</span> <span class="token class-name">Thread</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">//线程函数对象类型</span>
<span class="token keyword">using</span> ThreadFunc <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ThreadFunc 是 std::function 模板的实例化</span>
  <span class="token comment" spellcheck="true">//自C++11开始，using还可以用于定义类型别名，这类似于typedef但语法更为清晰。</span>
<span class="token comment" spellcheck="true">//其模板参数是 void()，表示接受零个参数、返回 void 的函数类型</span>

<span class="token comment" spellcheck="true">//线程构造</span>
<span class="token function">Thread</span><span class="token punctuation">(</span>ThreadFunc func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//线程析构</span>
<span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//启动线程</span>
<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//获取线程id</span>
<span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
ThreadFunc func_<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数对象 线程函数类型</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> generateId_<span class="token punctuation">;</span> 
<span class="token keyword">int</span> threadId_<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//保存线程Id</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/*
example:
ThreadPool pool;
pool.start(4);

class MyTask : public Task
&amp;#123;
public:
    void run()&amp;#123; //线程代码.... &amp;#125;
&amp;#125;

pool.submitTask(std::make_shared&lt;MyTask>());

*/</span>
</code></pre>
</blockquote>
<h3 id="5-Thread方法接口实现-线程方法实现"><a href="#5-Thread方法接口实现-线程方法实现" class="headerlink" title="5.Thread方法接口实现(线程方法实现)"></a>5.Thread方法接口实现(线程方法实现)</h3><p>thread线程的方法实现</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"threadpool.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;functional></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token comment" spellcheck="true">//二、线程方法实现</span>
<span class="token comment" spellcheck="true">//1.线程构造</span>
Thread<span class="token operator">::</span><span class="token function">Thread</span><span class="token punctuation">(</span>ThreadFunc func<span class="token punctuation">)</span>
<span class="token operator">:</span><span class="token function">func_</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">threadId_</span><span class="token punctuation">(</span>generateId_<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//2.线程析构</span>
Thread<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//1.启动线程</span>
<span class="token keyword">void</span> Thread<span class="token operator">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//创建一个线程来执行一个线程函数</span>
std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func_<span class="token punctuation">,</span>threadId_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//C++11来说 线程对象t 和线程函数func_</span>
t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置分离线程  linux中的 pthread_detach  pthread_t设置成分离线程,作用分离线程对象和线程函数func_</span>
         <span class="token comment" spellcheck="true">//线程对象t出了作用域会释放，但是线程函数func_不能释放，所以设置分离线程。</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//获取线程Id</span>
<span class="token keyword">int</span>  Thread<span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> threadId_<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//////////////////////   Task方法实现</span>
Task<span class="token operator">::</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">:</span><span class="token function">result_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> Task<span class="token operator">::</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>result_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  result_<span class="token operator">-</span><span class="token operator">></span><span class="token function">setVal</span><span class="token punctuation">(</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里发生多态调用；</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> Task<span class="token operator">::</span><span class="token function">setResult</span><span class="token punctuation">(</span>Result<span class="token operator">*</span> res<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
result_ <span class="token operator">=</span> res<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<p>在C++（特别是C++11及以后版本）中，<strong>分离线程</strong>的主要作用是用来管理线程生命周期和资源回收的方式。当一个线程被创建并启动后，默认情况下它是非分离（joinable）状态，这意味着线程执行完毕后，如果不通过某种方式（通常是调用<code>std::thread::join()</code>）获取其退出状态并等待它终止，那么线程资源不会立即释放，主线程或其他相关线程需要负责清理这些资源。</p>
<p>分离（detached）线程则是另一种线程生命周期管理模式，它允许线程在执行完毕后自行释放与其关联的所有资源，不需要其他线程显式地等待或尝试加入（join）它。一旦线程被分离，即使主线程或其他任何线程在此之前结束，操作系统也会自动回收分离线程占用的系统资源，包括栈空间和其他内部资源。</p>
<p>分离线程的优点在于：</p>
<ol>
<li><strong>资源自动回收</strong>：避免了因忘记或无法正确地调用<code>join()</code>而导致的资源泄露问题，尤其是对于那些执行完成后不需要返回结果的后台任务或守护线程特别有用。</li>
<li><strong>并发效率</strong>：由于线程结束时无需等待其他线程来回收资源，程序可以更快地响应和释放系统资源。</li>
<li><strong>无须同步</strong>：分离线程执行完毕后，不需要主线程或其他线程对其进行同步操作，减少了同步复杂度和潜在的死锁风险。</li>
</ol>
<p>在C++11中，使用<code>std::thread::detach()</code>方法可以使一个线程变为分离状态。一旦线程被分离，就无法再对该线程调用<code>join()</code>方法，因为此时线程已不再是joinable状态。</p>
<p>在C++中，一个线程对象（<code>std::thread</code>）的作用周期涵盖了从创建到销毁的过程，具体分为以下几个阶段：</p>
<ol>
<li><p><strong>创建</strong>： 当通过<code>std::thread</code>构造函数创建一个线程对象时，实际上创建了一个新的线程，该线程将执行传递给构造函数的可调用对象（如函数、函数对象、Lambda 表达式等）。</p>
<pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>thread <span class="token function">myThread</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建并启动一个线程</span>
</code></pre>
</li>
<li><p><strong>运行</strong>： 新创建的线程在调度器安排下开始执行其指定的任务。这个阶段的持续时间取决于线程要执行的代码逻辑。</p>
</li>
<li><p><strong>等待&#x2F;同步</strong>： 如果线程是joinable（非分离）状态，主线程或其他线程可以选择通过调用<code>std::thread::join()</code>方法等待该线程结束。在join操作完成之前，线程对象及其关联的资源（如线程堆栈）不会被销毁。</p>
<p>Cpp</p>
<pre class=" language-cpp"><code class="language-cpp">myThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待myThread执行完毕</span>
</code></pre>
</li>
<li><p><strong>分离</strong>： 若选择对线程对象调用<code>std::thread::detach()</code>方法，则该线程将变为分离状态。分离后的线程在其执行完毕后，系统会自动回收其资源，无需调用<code>join()</code>。</p>
<p>Cpp</p>
<pre class=" language-cpp"><code class="language-cpp">myThread<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分离线程，线程结束后资源会被自动回收</span>
</code></pre>
</li>
<li><p><strong>销毁</strong>： 当线程对象离开其作用范围，或手动调用析构函数时，如果线程仍然是joinable状态且尚未被<code>join()</code>或<code>detach()</code>，则程序的行为未定义（可能导致资源泄露或异常）。正确的做法是在线程结束前确保其已经被<code>join()</code>或<code>detach()</code>。</p>
</li>
</ol>
<p>总结来说，线程对象的作用周期应当包括创建、运行、等待&#x2F;同步（join或detach）以及最终的销毁。在实际编程中，应确保妥善管理线程的生命周期，防止出现资源泄露或其他未定义行为。</p>
<h4 id="5-1threadfunc-线程函数实现"><a href="#5-1threadfunc-线程函数实现" class="headerlink" title="5.1threadfunc()线程函数实现"></a>5.1threadfunc()线程函数实现</h4><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//定义线程函数   线程池的所有线程从任务队列里面消费任务</span>
<span class="token keyword">void</span> ThreadPool<span class="token operator">::</span><span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadid<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//线程函数返回，相应的线程也就结束了</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> lastTime <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/*std::cout &lt;&lt; "begin threadFunc tid: " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
std::cout &lt;&lt; "end threadFunc tid: " &lt;&lt;std::this_thread::get_id() &lt;&lt; std::endl;*/</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Task<span class="token operator">></span>task<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//先获取锁</span>
      std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span><span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>


      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tid: "</span> <span class="token operator">&lt;&lt;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"尝试获取任务..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

      <span class="token comment" spellcheck="true">//cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程回收掉</span>
      <span class="token comment" spellcheck="true">//结束回收掉？(超过initThreadSize_数量的线程要进行回收)</span>
      <span class="token comment" spellcheck="true">//当前时间-上一次线程执行的时间 > 60s</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>poolMode_ <span class="token operator">==</span> PoolMode<span class="token operator">::</span>MODE_CACHED<span class="token punctuation">)</span>
      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//每一秒钟返回一次    怎么区分：超时返回？ 还是有任务待执行返回</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
              <span class="token comment" spellcheck="true">//条件变量，超时返回了</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cv_status<span class="token operator">::</span>timeout <span class="token operator">==</span>
                  notEmpty_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                  <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">auto</span> dur <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>seconds<span class="token operator">></span><span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>dur<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> THREAD_MAX_IDLE_TIME
                      <span class="token operator">&amp;&amp;</span> curThreadSize_<span class="token operator">></span>initThreadSize_<span class="token punctuation">)</span>
                  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                      <span class="token comment" spellcheck="true">//开始回收当前线程</span>
                      <span class="token comment" spellcheck="true">//记录线程数量的相关变量的值修改</span>
                      <span class="token comment" spellcheck="true">//把线程对象从线程列表容器中删除   没有办法 threadFunc   匹配哪个thread对象</span>
                      <span class="token comment" spellcheck="true">//threadid => thread对象 => 删除</span>
                      threads_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>threadid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//std::this_thread::getid()</span>
                      curThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>
                      idleThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>

                      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"exit!"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
                      <span class="token keyword">return</span><span class="token punctuation">;</span>
                  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span>
      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//等待notEmpty条件</span>
          notEmpty_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


      <span class="token comment" spellcheck="true">//等待notEmpty条件</span>
      notEmpty_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      idleThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>

      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tid: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"获取任务成功..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

      <span class="token comment" spellcheck="true">//从任务队列中取出一个任务出来</span>
      <span class="token keyword">auto</span> task <span class="token operator">=</span> taskQue_<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      taskQue_<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      taskSize_<span class="token operator">--</span><span class="token punctuation">;</span> 

      <span class="token comment" spellcheck="true">//如果依然有剩余任务，继续通知其他的线程执行任务</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

      <span class="token comment" spellcheck="true">//取出一个任务，进行通知,通知继续生产任务</span>
      notFull_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//就应该把锁释放掉  别的线程也能去取任务去执行，或者用户能够取到锁提交任务</span>
  <span class="token comment" spellcheck="true">//作用域的原因，局部对象出作用域自动析构，把锁释放掉。</span>


  <span class="token comment" spellcheck="true">//从当前线程负责执行这个任务</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//task->run(); //基类指针指向那个派生类对象，就会调用派生类的同名覆盖方法；</span>
                <span class="token comment" spellcheck="true">//1. 执行任务；2. 把任务的返回值setVal方法给到Result</span>
      task<span class="token operator">-</span><span class="token operator">></span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
  lastTime <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 更新线程执行完任务的时间</span>

  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h3 id="6-linux编译线程池动态库"><a href="#6-linux编译线程池动态库" class="headerlink" title="6.linux编译线程池动态库"></a>6.linux编译线程池动态库</h3><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//生成动态库</span>
g<span class="token operator">++</span> <span class="token operator">-</span>fPIC <span class="token operator">-</span>shared threadpool<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o libtdpool<span class="token punctuation">.</span>so <span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">17</span>
</code></pre>
<p>linux从 &#x2F;usr&#x2F;lib  &#x2F;usr&#x2F;local&#x2F;lib  找静态库  .a  动态库  .so</p>
<p>从  &#x2F;usr&#x2F;include  &#x2F;usr&#x2F;local&#x2F;include 找 *.h </p>
<p>将threadpool.h 放入 &#x2F;usr&#x2F;local&#x2F;include&#x2F;, 生成的动态库libtdpool.so 放到&#x2F;usr&#x2F;local&#x2F;lib&#x2F;, 删除threadpool.cpp源文件</p>
<pre class=" language-cpp"><code class="language-cpp">g<span class="token operator">++</span> 线程池项目测试<span class="token punctuation">.</span>cpp <span class="token operator">-</span>std<span class="token operator">=</span>c<span class="token operator">++</span><span class="token number">17</span> <span class="token operator">-</span>ltdpool <span class="token operator">-</span>lpthread
</code></pre>
</blockquote>
<p>程序编译时候会从 &#x2F;usr&#x2F;lib  &#x2F;usr&#x2F;local&#x2F;lib查询动态库, 程序运行阶段 会从&#x2F;etc&#x2F;ld.so.conf查找 :解决方法在&#x2F;etc&#x2F;ld.so.conf.d&#x2F; 添加一个myconf配置文件,加入路径</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp">ldconfig  <span class="token comment" spellcheck="true">//将myconf文件添加的路径刷新到 /etc/ld.so.cache</span>
</code></pre>
</blockquote>
<h3 id="7-线程池使用说明"><a href="#7-线程池使用说明" class="headerlink" title="7.线程池使用说明"></a>7.线程池使用说明</h3><p>用户使用说明</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp">example<span class="token operator">:</span>
ThreadPool pool<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义线程池</span>
pool<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//启动四个线程</span>

<span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token operator">:</span> <span class="token keyword">public</span> Task  
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//线程代码.... &amp;#125; //重写run方法</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyTask<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用户提交任务</span>
<span class="token comment" spellcheck="true">//make_shared&lt;MyTask>()创建对象的好处是,同时创建对象内存和对象引用计数的内存,以免产生对象分配成功,却无法释放的现象</span>
</code></pre>
</blockquote>
<h3 id="8-优化线程池代码-基于可变参模板编程"><a href="#8-优化线程池代码-基于可变参模板编程" class="headerlink" title="8.优化线程池代码-基于可变参模板编程"></a>8.优化线程池代码-基于可变参模板编程</h3><h4 id="8-1packaged-task和future机制"><a href="#8-1packaged-task和future机制" class="headerlink" title="8.1packaged_task和future机制"></a>8.1packaged_task和future机制</h4><h5 id="packaged-task和future机制"><a href="#packaged-task和future机制" class="headerlink" title="packaged_task和future机制 ?"></a>packaged_task和future机制 ?</h5><p>在C++11及后续标准中，<code>std::future</code> 和 <code>std::packaged_task</code> 是两个用于处理异步计算结果的核心组件，它们都在 <code>&lt;future&gt;</code> 标准库中定义。</p>
<p><strong>std::packaged_task</strong> <code>std::packaged_task</code> 是一个类模板，它能够封装任何可调用对象（包括函数、lambda 表达式、<code>std::bind</code> 结果等），并将其实现为可以异步执行的任务。当 <code>std::packaged_task</code> 实例化时，它会与一个 <code>std::future</code> 关联，这个 <code>future</code> 对象随后可以用来查询封装任务的结果。</p>
<p>使用 <code>std::packaged_task</code> 的典型步骤如下：</p>
<ol>
<li>创建一个 <code>std::packaged_task</code> 实例，传入想要异步执行的可调用对象。</li>
<li>通过调用 <code>packaged_task::get_future()</code> 获取与该任务关联的 <code>std::future</code> 对象，这个 future 将用于检索任务完成后产生的结果。</li>
<li>将 <code>std::packaged_task</code> 传递给某个线程进行执行，通常是通过 <code>std::thread</code> 或者 <code>std::async</code>，或者在事件循环中调度执行。</li>
<li>当任务完成后，<code>packaged_task</code> 会将其计算结果放入与其关联的 <code>std::future</code> 中。</li>
<li>在主线程或者其他需要结果的线程中，通过调用前面得到的 <code>future</code> 对象的 <code>get()</code> 方法来等待并获取结果。</li>
</ol>
<p><strong>std::future</strong> <code>std::future</code> 是一个表示异步计算结果的容器对象。它可以容纳由另一个线程执行的函数的结果或异常。一旦异步操作完成，<code>std::future</code> 对象可以通过调用其 <code>get()</code> 方法来获取结果或者重新抛出捕获的异常。<code>std::future</code> 有以下关键特性：</p>
<ul>
<li><strong>异步等待结果</strong>：<code>get()</code> 方法可以阻塞当前线程直到异步操作完成并获取结果。</li>
<li><strong>共享状态</strong>：同一份计算结果可以被多个 <code>std::future</code> 共享，每个 <code>std::future</code> 都指向同一个异步计算的结果。</li>
<li><strong>单次获取</strong>：每个 <code>std::future</code> 对象上的 <code>get()</code> 只能调用一次，再次调用会导致未定义行为（通常表现为抛出异常）。</li>
</ul>
<p><code>std::future</code> 是一个接口，用于从异步操作接收结果，而 <code>std::packaged_task</code> 则是一个工具，它提供了一种创建和管理异步任务的方式，并且自动生成了与任务结果对应的 <code>std::future</code> 对象。两者结合使用，极大地简化了C++中异步编程模型的设计和实现。</p>
<h4 id="8-2优化思路"><a href="#8-2优化思路" class="headerlink" title="8.2优化思路"></a>8.2优化思路</h4><p>如何能让线程池提交任务更加方便</p>
<ol>
<li><p>pool.submitTask(sum1, 10, 20);<br>pool.submitTask(sum2, 1 ,2, 3);<br>submitTask:可变参模板编程</p>
</li>
<li><p>之前造了一个Result Any Semaphore的类型，代码挺多<br>C++11 线程库   thread   packaged_task(function函数对象)  async<br>使用future来代替Result节省线程池代码</p>
</li>
</ol>
<p>去除第一版代码中的Any Semaphore Result task类,使用可变参模板编程, 让submitTask可以接受任意函数和数量的参数</p>
<blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 给线程池提交任务</span>
<span class="token comment" spellcheck="true">// 使用可变参模板编程，让submitTask可以接收任意任务函数和任意数量的参数</span>
<span class="token comment" spellcheck="true">// pool.submitTask(sum1, 10, 20);   </span>
<span class="token comment" spellcheck="true">// 返回值future&lt;返回值类型> 使用decltype进行类型推导</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Func<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">submitTask</span><span class="token punctuation">(</span>Func<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 打包任务，放入任务队列里面</span>
    <span class="token keyword">using</span> RType <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> task <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">RType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>
        std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Func<span class="token operator">></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span>RType<span class="token operator">></span> result <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 获取锁</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>notFull_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>taskQueMaxThreshHold_<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 表示notFull_等待1s种，条件依然没有满足</span>
        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"task queue is full, submit task fail."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">auto</span> task <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">RType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>
            <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>RType <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">RType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> task<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>
<h4 id="8-3ThreadPool设计实现"><a href="#8-3ThreadPool设计实现" class="headerlink" title="8.3ThreadPool设计实现"></a>8.3ThreadPool设计实现</h4><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> THREADPOOL_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> THREADPOOL_H</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span>

<span class="token keyword">const</span> <span class="token keyword">int</span> TASK_MAX_THRESHHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// INT32_MAX;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> THREAD_MAX_THRESHHOLD <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> THREAD_MAX_IDLE_TIME <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单位：秒</span>


<span class="token comment" spellcheck="true">// 线程池支持的模式</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">PoolMode</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
MODE_FIXED<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 固定数量的线程</span>
MODE_CACHED<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程数量可动态增长</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 线程类型</span>
<span class="token keyword">class</span> <span class="token class-name">Thread</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">// 线程函数对象类型</span>
<span class="token keyword">using</span> ThreadFunc <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 线程构造</span>
<span class="token function">Thread</span><span class="token punctuation">(</span>ThreadFunc func<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">func_</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">threadId_</span><span class="token punctuation">(</span>generateId_<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 线程析构</span>
<span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 启动线程</span>
<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建一个线程来执行一个线程函数 pthread_create</span>
    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func_<span class="token punctuation">,</span> threadId_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// C++11来说 线程对象t  和线程函数func_</span>
    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置分离线程   pthread_detach  pthread_t设置成分离线程</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 获取线程id</span>
<span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> threadId_<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
ThreadFunc func_<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> generateId_<span class="token punctuation">;</span>
<span class="token keyword">int</span> threadId_<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 保存线程id</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> Thread<span class="token operator">::</span>generateId_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 线程池类型</span>
<span class="token keyword">class</span> <span class="token class-name">ThreadPool</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">// 线程池构造</span>
<span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">initThreadSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">taskSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">idleThreadSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">curThreadSize_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">taskQueMaxThreshHold_</span><span class="token punctuation">(</span>TASK_MAX_THRESHHOLD<span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">threadSizeThreshHold_</span><span class="token punctuation">(</span>THREAD_MAX_THRESHHOLD<span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">poolMode_</span><span class="token punctuation">(</span>PoolMode<span class="token operator">::</span>MODE_FIXED<span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">isPoolRunning_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 线程池析构</span>
<span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    isPoolRunning_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 等待线程池里面所有的线程返回  有两种状态：阻塞 &amp; 正在执行任务中</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    exitCond_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> threads_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 设置线程池的工作模式</span>
<span class="token keyword">void</span> <span class="token function">setMode</span><span class="token punctuation">(</span>PoolMode mode<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    poolMode_ <span class="token operator">=</span> mode<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 设置task任务队列上线阈值</span>
<span class="token keyword">void</span> <span class="token function">setTaskQueMaxThreshHold</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshhold<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    taskQueMaxThreshHold_ <span class="token operator">=</span> threshhold<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 设置线程池cached模式下线程阈值</span>
<span class="token keyword">void</span> <span class="token function">setThreadSizeThreshHold</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshhold<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>poolMode_ <span class="token operator">==</span> PoolMode<span class="token operator">::</span>MODE_CACHED<span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        threadSizeThreshHold_ <span class="token operator">=</span> threshhold<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 给线程池提交任务</span>
<span class="token comment" spellcheck="true">// 使用可变参模板编程，让submitTask可以接收任意任务函数和任意数量的参数</span>
<span class="token comment" spellcheck="true">// pool.submitTask(sum1, 10, 20);   </span>
<span class="token comment" spellcheck="true">// 返回值future&lt;></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Func<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">submitTask</span><span class="token punctuation">(</span>Func<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 打包任务，放入任务队列里面</span>
    <span class="token keyword">using</span> RType <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> task <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">RType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>
        std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Func<span class="token operator">></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span>RType<span class="token operator">></span> result <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 获取锁</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>notFull_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>taskQueMaxThreshHold_<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 表示notFull_等待1s种，条件依然没有满足</span>
        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"task queue is full, submit task fail."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">auto</span> task <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">RType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">(</span>
            <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>RType <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">RType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> task<span class="token operator">-</span><span class="token operator">></span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 如果有空余，把任务放入任务队列中</span>
    <span class="token comment" spellcheck="true">// taskQue_.emplace(sp);  </span>
    <span class="token comment" spellcheck="true">// using Task = std::function&lt;void()>;</span>
    taskQue_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token punctuation">[</span>task<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    taskSize_<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 因为新放了任务，任务队列肯定不空了，在notEmpty_上进行通知，赶快分配线程执行任务</span>
    notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// cached模式 任务处理比较紧急 场景：小而快的任务 需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程出来</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>poolMode_ <span class="token operator">==</span> PoolMode<span class="token operator">::</span>MODE_CACHED
        <span class="token operator">&amp;&amp;</span> taskSize_ <span class="token operator">></span> idleThreadSize_
        <span class="token operator">&amp;&amp;</span> curThreadSize_ <span class="token operator">&lt;</span> threadSizeThreshHold_<span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">">>> create new thread..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 创建新的线程对象</span>
        <span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ThreadPool<span class="token operator">::</span>threadFunc<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> threadId <span class="token operator">=</span> ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>threadId<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 启动线程</span>
        threads_<span class="token punctuation">[</span>threadId<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 修改线程个数相关的变量</span>
        curThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
        idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 返回任务的Result对象</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 开启线程池</span>
<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> initThreadSize <span class="token operator">=</span> std<span class="token operator">::</span>thread<span class="token operator">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 设置线程池的运行状态</span>
    isPoolRunning_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 记录初始线程个数</span>
    initThreadSize_ <span class="token operator">=</span> initThreadSize<span class="token punctuation">;</span>
    curThreadSize_ <span class="token operator">=</span> initThreadSize<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 创建线程对象</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> initThreadSize_<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span>
        <span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ThreadPool<span class="token operator">::</span>threadFunc<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> threadId <span class="token operator">=</span> ptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads_<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>threadId<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// threads_.emplace_back(std::move(ptr));</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 启动所有线程  std::vector&lt;Thread*> threads_;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> initThreadSize_<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        threads_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要去执行一个线程函数</span>
        idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录初始空闲线程的数量</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadPool<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
ThreadPool<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadPool<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment" spellcheck="true">// 定义线程函数</span>
<span class="token keyword">void</span> <span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadid<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> lastTime <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 所有任务必须执行完成，线程池才可以回收所有线程资源</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        Task task<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 先获取锁</span>
            std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>taskQueMtx_<span class="token punctuation">)</span><span class="token punctuation">;</span>

            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">&lt;&lt;</span> <span class="token string">"尝试获取任务..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span>
            <span class="token comment" spellcheck="true">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span>
            <span class="token comment" spellcheck="true">// 当前时间 - 上一次线程执行的时间 > 60s</span>

            <span class="token comment" spellcheck="true">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span>
            <span class="token comment" spellcheck="true">// 锁 + 双重判断</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 线程池要结束，回收线程资源</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isPoolRunning_<span class="token punctuation">)</span>
                <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    threads_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>threadid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// std::this_thread::getid()</span>
                    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" exit!"</span>
                        <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
                    exitCond_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程函数结束，线程结束</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>poolMode_ <span class="token operator">==</span> PoolMode<span class="token operator">::</span>MODE_CACHED<span class="token punctuation">)</span>
                <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 条件变量，超时返回了</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cv_status<span class="token operator">::</span>timeout <span class="token operator">==</span>
                        notEmpty_<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">auto</span> dur <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>seconds<span class="token operator">></span><span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dur<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> THREAD_MAX_IDLE_TIME
                            <span class="token operator">&amp;&amp;</span> curThreadSize_ <span class="token operator">></span> initThreadSize_<span class="token punctuation">)</span>
                        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// 开始回收当前线程</span>
                            <span class="token comment" spellcheck="true">// 记录线程数量的相关变量的值修改</span>
                            <span class="token comment" spellcheck="true">// 把线程对象从线程列表容器中删除   没有办法 threadFunc《=》thread对象</span>
                            <span class="token comment" spellcheck="true">// threadid => thread对象 => 删除</span>
                            threads_<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>threadid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// std::this_thread::getid()</span>
                            curThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>
                            idleThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>

                            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" exit!"</span>
                                <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
                            <span class="token keyword">return</span><span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 等待notEmpty条件</span>
                    notEmpty_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            idleThreadSize_<span class="token operator">--</span><span class="token punctuation">;</span>

            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tid:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">&lt;&lt;</span> <span class="token string">"获取任务成功..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 从任务队列种取一个任务出来</span>
            task <span class="token operator">=</span> taskQue_<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            taskQue_<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            taskSize_<span class="token operator">--</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 如果依然有剩余任务，继续通知其它得线程执行任务</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>taskQue_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                notEmpty_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 取出一个任务，进行通知，通知可以继续提交生产任务</span>
            notFull_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 就应该把锁释放掉</span>

        <span class="token comment" spellcheck="true">// 当前线程负责执行这个任务</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行function&lt;void()> </span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        idleThreadSize_<span class="token operator">++</span><span class="token punctuation">;</span>
        lastTime <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">high_resolution_clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新线程执行完任务的时间</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 检查pool的运行状态</span>
<span class="token keyword">bool</span> <span class="token function">checkRunningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> isPoolRunning_<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Thread<span class="token operator">>></span> threads_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程列表</span>

<span class="token keyword">int</span> initThreadSize_<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始的线程数量</span>
<span class="token keyword">int</span> threadSizeThreshHold_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程数量上限阈值</span>
std<span class="token operator">::</span>atomic_int curThreadSize_<span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">// 记录当前线程池里面线程的总数量</span>
std<span class="token operator">::</span>atomic_int idleThreadSize_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录空闲线程的数量</span>

<span class="token comment" spellcheck="true">// Task任务 =》 函数对象</span>
<span class="token keyword">using</span> Task <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
std<span class="token operator">::</span>queue<span class="token operator">&lt;</span>Task<span class="token operator">></span> taskQue_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任务队列</span>
std<span class="token operator">::</span>atomic_int taskSize_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任务的数量</span>
<span class="token keyword">int</span> taskQueMaxThreshHold_<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 任务队列数量上限阈值</span>

std<span class="token operator">::</span>mutex taskQueMtx_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证任务队列的线程安全</span>
std<span class="token operator">::</span>condition_variable notFull_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示任务队列不满</span>
std<span class="token operator">::</span>condition_variable notEmpty_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示任务队列不空</span>
std<span class="token operator">::</span>condition_variable exitCond_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等到线程资源全部回收</span>

PoolMode poolMode_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前线程池的工作模式</span>
std<span class="token operator">::</span>atomic_bool isPoolRunning_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示当前线程池的启动状态</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre>
</blockquote>
<h4 id="8-4ThreadPool实现"><a href="#8-4ThreadPool实现" class="headerlink" title="8.4ThreadPool实现"></a>8.4ThreadPool实现</h4><blockquote>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 线程池项目-最终版.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span>
<span class="token comment" spellcheck="true">//</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"threadpool.h"</span></span>





<span class="token keyword">int</span> <span class="token function">sum1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 比较耗时</span>
<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sum2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// io线程 </span>
<span class="token keyword">void</span> <span class="token function">io_thread</span><span class="token punctuation">(</span><span class="token keyword">int</span> listenfd<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// worker线程</span>
<span class="token keyword">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token keyword">int</span> clientfd<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
ThreadPool pool<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// pool.setMode(PoolMode::MODE_CACHED);</span>
pool<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> r1 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span>sum1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> r2 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span>sum2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> r3 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> b<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> e<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
      sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> r4 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> b<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> e<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
      sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> r5 <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submitTask</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> b<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> e<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
      sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//future&lt;int> r4 = pool.submitTask(sum1, 1, 2);</span>

cout <span class="token operator">&lt;&lt;</span> r1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> r2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> r3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> r4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> r5<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//packaged_task&lt;int(int, int)> task(sum1);</span>
<span class="token comment" spellcheck="true">//// future &lt;=> Result</span>
<span class="token comment" spellcheck="true">//future&lt;int> res = task.get_future();</span>
<span class="token comment" spellcheck="true">//// task(10, 20);</span>
<span class="token comment" spellcheck="true">//thread t(std::move(task), 10, 20);</span>
<span class="token comment" spellcheck="true">//t.detach();</span>

<span class="token comment" spellcheck="true">//cout &lt;&lt; res.get() &lt;&lt; endl;</span>

<span class="token comment" spellcheck="true">/*thread t1(sum1, 10, 20);
thread t2(sum2, 1, 2, 3);

t1.join();
t2.join();*/</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Merlin</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://MerlinCLZ.github.io/%E5%9F%BA%E4%BA%8EC-11%E5%8F%AF%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">http://MerlinCLZ.github.io/%E5%9F%BA%E4%BA%8EC-11%E5%8F%AF%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Merlin</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/">
                                    <span class="chip bg-color">个人项目</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/%E7%AC%AC40%E8%AE%B2-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%EF%BC%9A%E6%8E%88%E4%BA%BA%E4%BB%A5%E9%B1%BC%E4%B8%8D%E5%A6%82%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-03-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Merlin
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/C-11-thread%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="C++11-thread多线程-线程互斥和同步通信-死锁问题">
                        
                        <span class="card-title">C++11-thread多线程-线程互斥和同步通信-死锁问题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-01-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Merlin
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                    <a href="/tags/C-11/">
                        <span class="chip bg-color">C++11</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">Merlin</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/MerlinClZ" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:11343235143@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1134323514" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1134323514" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
